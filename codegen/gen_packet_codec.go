//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

// Field represents a single field in a packet struct
type Field struct {
	Name      string // The Struct field name (e.g., "ProtocolVersion")
	FieldType string // The high-level type (e.g., "VarInt", "PrefixedArray", "Optional")
	WriteFn   string
	ReadFn    string
}

// GeneratedStruct represents a struct found in the source code marked for generation
type GeneratedStruct struct {
	Name   string
	Fields []Field
}

func main() {
	if len(os.Args) < 2 {
		// Default to current directory if no arg provided, or panic as per original requirement
		fmt.Println("Usage: go run gen_packet_codec.go -- path/to/dir")
		os.Exit(1)
	}

	targetDir := os.Args[len(os.Args)-1] // Take the last argument as the directory
	fset := token.NewFileSet()
	var structs []GeneratedStruct
	var pkgName string

	files, _ := filepath.Glob(filepath.Join(targetDir, "*.go"))

	for _, file := range files {
		// Skip generated files to avoid double parsing
		if strings.HasPrefix(filepath.Base(file), "zz_generated") {
			continue
		}

		node, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}

		if pkgName == "" {
			pkgName = node.Name.Name
		}

		// Walk through top-level declarations
		for _, decl := range node.Decls {
			gen, ok := decl.(*ast.GenDecl)

			// filter for only type declarations with comments
			if !ok || gen.Tok != token.TYPE || gen.Doc == nil {
				continue
			}

			// filter for types with @gen in doc comment
			if !strings.Contains(gen.Doc.Text(), "@gen") {
				continue
			}

			for _, spec := range gen.Specs {
				tspec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				// type assertion for struct type
				structType, ok := tspec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				var fields []Field
				for _, field := range structType.Fields.List {
					for _, name := range field.Names {

						// Get the raw tag string
						rawTag := ""
						if field.Tag != nil {
							// The Value is a BasicLit (string literal), strip the quotes
							rawTag = field.Tag.Value
							if len(rawTag) > 1 && rawTag[0] == '`' && rawTag[len(rawTag)-1] == '`' {
								rawTag = rawTag[1 : len(rawTag)-1] // Remove backticks
							}
						}

						// Use reflect.StructTag to parse the raw string
						parsedTag := reflect.StructTag(rawTag)
						fieldType := parsedTag.Get("field")
						writeFn := ""
						readFn := ""

						innerType := parsedTag.Get("inner")
						if len(innerType) > 0 {
							writeFn = "Write" + innerType
							readFn = "Read" + innerType
						} else {
							writeFn = parsedTag.Get("write")
							readFn = parsedTag.Get("read")
						}

						if fieldType == "" {
							continue // Skip fields without the "field" tag
						}

						f := Field{
							Name:      name.Name,
							FieldType: fieldType,
							WriteFn:   writeFn,
							ReadFn:    readFn,
						}

						fields = append(fields, f)
					}
				}

				structs = append(structs, GeneratedStruct{
					Name:   tspec.Name.Name,
					Fields: fields,
				})
			}
		}
	}

	// Output next to the source files
	outFile := filepath.Join(targetDir, "zz_generated_codec.go")
	out, err := os.Create(outFile)
	if err != nil {
		panic(err)
	}
	defer out.Close()

	// Use a template for cleaner code generation logic
	const tmpl = `// Code generated by gen_packet_codec.go; DO NOT EDIT.
package {{.PkgName}}

import (
	"io"
)
{{range .Structs}}
func (p {{.Name}}) Encode(w io.Writer) (err error) {
{{- range .Fields}}
	{{- if .WriteFn}}
	if err = Write{{.FieldType}}(w, p.{{.Name}}, {{.WriteFn}}); err != nil { return }
	{{- else}}
	if err = Write{{.FieldType}}(w, p.{{.Name}}); err != nil { return }
	{{- end}}
{{- end}}
	return
}

func (p *{{.Name}}) Decode(r io.Reader) (err error) {
{{- range .Fields}}
	{{- if .ReadFn}}
	if p.{{.Name}}, err = Read{{.FieldType}}(r, {{.ReadFn}}); err != nil { return }
	{{- else}}
	if p.{{.Name}}, err = Read{{.FieldType}}(r); err != nil { return }
	{{- end}}
{{- end}}
	return nil
}
{{end}}
`

	t := template.Must(template.New("code").Parse(tmpl))
	data := struct {
		PkgName string
		Structs []GeneratedStruct
	}{
		PkgName: pkgName,
		Structs: structs,
	}

	if err := t.Execute(out, data); err != nil {
		panic(err)
	}

	fmt.Printf("Generated %s for package %s\n", outFile, pkgName)
}
